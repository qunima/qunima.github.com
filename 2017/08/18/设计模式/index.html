<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>设计模式 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写给大家看的设计模式。">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://yoursite.com/2017/08/18/设计模式/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="写给大家看的设计模式。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2017-08-18T02:24:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式">
<meta name="twitter:description" content="写给大家看的设计模式。">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/18/设计模式/" class="article-date">
  <time datetime="2017-08-18T02:06:34.000Z" itemprop="datePublished">2017-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写给大家看的设计模式。<br><a id="more"></a></p>
<blockquote>
<p>原文收录在<a href="http://pushmind.org/2017/07/31/design-patterns-for-humans/" target="_blank" rel="noopener">我的博客</a>, 欢迎光临.</p>
</blockquote>
<p>本文是针对 <a href="https://github.com/kamranahmedse/design-patterns-for-humans" target="_blank" rel="noopener">https://github.com/kamranahme…</a> 的翻译与笔记, 会结合部分个人理解. 若您发现有明显理解有误的地方, 及疏漏之处, 麻烦留言指正, 在下不胜感激.</p>
<blockquote>
<p>标题的解读: 设计模式与重构号称软工双雄, 在软件工程领域可谓智慧的结晶, 尤其是设计模式, 由于其高度抽象与最佳实践的特性, 导致初学者以及编程经验不足者, 读此如读天书. 所谓”给人读的”, 就是将设计模式请下神坛, 用更容易理解的角度来介绍其精髓. 本人大学时期曾读过一本&lt;大话设计模式&gt;, 就走的通俗易懂之路, 然而, 通俗不能有失准确, 易懂不能理解偏差. 差之毫厘, 谬以千里. 闻者足戒.</p>
<p>Explain them in the simplest way possible. — 作者的话</p>
</blockquote>
<h2 id="🚀-初窥门径"><a href="#🚀-初窥门径" class="headerlink" title="🚀 初窥门径"></a>🚀 初窥门径</h2><p>软工的江湖, 有一个原则贯穿始终, 有如剑道: DRY(don’t repeat yourself). 无数先哲们, 想尽各种办法来解决这个终极问题. 所谓设计模式, 就是其中最著名的一个解决方案, 其作者有四位, <del>号称”东邪, 西毒…”</del>. 而这种办法, 早已不是一招一式, 不是什么特定的类, 库, 代码, 你没法 include, import 一下就坐享其成. 这些方法被称之为 guidelines, 如果直译的话, 就是指导方针. 听起来比较虚一点, 但它们的确是针对具体问题的.</p>
<p>这里引入 Wikipedia 的描述:</p>
<blockquote>
<p>In software engineering, a software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations.</p>
</blockquote>
<p>这可能说的更加精确一些, 但意思就是上述那意思.</p>
<h3 id="⚠️-小心"><a href="#⚠️-小心" class="headerlink" title="⚠️ 小心"></a>⚠️ 小心</h3><ul>
<li>设计模式<strong>不是银弹</strong>(废话, 根本没有银弹)</li>
<li><strong>不要教条, 不要中二, 也不要强迫症.</strong> 如果陷入以上三种状态, 请牢记: 设计模式是用来解决问题的, 而不是用来找茬的.</li>
<li><strong>因地制宜</strong>, 就是天使, 否则, 则是魔鬼.</li>
</ul>
<p>原作者使用 PHP7 作为示例代码, 而恰好本人完全不会宇宙最好语言, 只好用老土的 C++ 来阐述.</p>
<h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><ul>
<li><a>创建型</a></li>
<li><a>结构型</a></li>
<li><a>行为型</a></li>
</ul>
<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>简言之:</p>
<blockquote>
<p>创建型模式, 是针对如何<strong>创建对象</strong>的解决方案</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, creational design patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p>
</blockquote>
<ul>
<li><a>简单工厂</a></li>
<li><a>工厂方法</a></li>
<li><a>抽象工厂</a></li>
<li><a>生成器</a></li>
<li><a>原型</a></li>
<li><a>单例</a></li>
</ul>
<h3 id="🏠-简单工厂"><a href="#🏠-简单工厂" class="headerlink" title="🏠 简单工厂"></a>🏠 简单工厂</h3><p>真实案例:</p>
<blockquote>
<p>造房子时需要一个门. 你是穿上木匠服开始在你家门口锯木头, 搞得一团糟; 还是从工厂里生产一个.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>简单工厂为用户提供了一个实例, 而隐藏了具体的实例化逻辑.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In object-oriented programming (OOP), a factory is an object for creating other objects – formally a factory is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be “new”.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual float GetWidth() = 0;</span><br><span class="line">    virtual float GetHeight() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WoodenDoor : public IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    WoodenDoor(float width, float height): m_width(width), m_height(height)&#123;&#125;</span><br><span class="line">    float GetWidth() override &#123; return m_width; &#125;</span><br><span class="line">    float GetHeight() override &#123; return m_height; &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    float m_width;</span><br><span class="line">    float m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DoorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">    static IDoor* MakeDoor(float width, float heigh)</span><br><span class="line">    &#123;</span><br><span class="line">        return new WoodenDoor(width, heigh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IDoor* door = DoorFactory::MakeDoor(100, 200);</span><br><span class="line">    std::cout &lt;&lt; &quot;Width: &quot; &lt;&lt; door-&gt;GetWidth() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Height: &quot; &lt;&lt; door-&gt;GetHeight() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用时机</strong>:</p>
<p>当你创建一个对象, 并非简单拷贝赋值, 牵扯很多其他逻辑时, 就应该把它放到一个专门的工厂中, 而不是每次都重复. 这个体现在 C++ 中, 主要就是将 new 语句的逻辑抽象到一个单例, 或者如上述例子一样, 扔到一个统一的静态函数中去.</p>
<p><strong>本质</strong>:</p>
<p>其实就是”抽象”在<strong>创建对象</strong>时的一个具体体现.</p>
<h3 id="🏭-工厂方法"><a href="#🏭-工厂方法" class="headerlink" title="🏭 工厂方法"></a>🏭 工厂方法</h3><p>真实案例:</p>
<blockquote>
<p>如果你主管招聘, 你肯定无法做到什么职位都由你一个人来面试. 根据具体的工作性质, 你需要选择并委托不同的人来按步骤进行面试.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>一种将实例化逻辑委托给<strong>子类</strong>的方法</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class IInterviewer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void askQuestions() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Developer : public IInterviewer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void askQuestions() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Asking about design patterns!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CommunityExecutive : public IInterviewer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void askQuestions() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Asking about community building!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HiringManager</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void takeInterview() &#123;</span><br><span class="line">        IInterviewer* interviewer = this-&gt;makeInterviewer();</span><br><span class="line">        interviewer-&gt;askQuestions();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    virtual IInterviewer* makeInterviewer() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Interviewer&gt;</span><br><span class="line">class OtherManager : public HiringManager &#123;</span><br><span class="line">protected:</span><br><span class="line">    IInterviewer* makeInterviewer() override &#123;</span><br><span class="line">        return new Interviewer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HiringManager* devManager = new OtherManager&lt;Developer&gt;();</span><br><span class="line">    devManager-&gt;takeInterview();</span><br><span class="line"></span><br><span class="line">    HiringManager* marketingManager = new OtherManager&lt;CommunityExecutive&gt;();</span><br><span class="line">    marketingManager-&gt;takeInterview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用时机</strong>:</p>
<p>当一个类中有一些通用的处理, 但要等到运行时决定用哪个子类的实现. 换句话说, 当客户并不知道他需要哪一个子类时.</p>
<p><strong>解释</strong>:</p>
<ul>
<li>客户并不知道他需要哪一个子类? 他分明指定了委托人: 开发部主管和市场部主管!</li>
</ul>
<p>要注意, 这里我们抽象的对象是面试这个过程, 作为用户, 它只知道 Interview 这个接口, 而不清楚这个 Interview 的派生关系. 也就是说作为招聘主管(用户), 他只是找来了开发主管, 市场主管. 然后他说:”面试一下”. 他并不知道会面试些什么内容, 什么形式. 这些就是被封装的部分. 这就是上述”不知道需要哪一个子类”的具体解释.</p>
<ul>
<li>这和简单工厂有啥区别?</li>
</ul>
<p>平心而论, 这篇文章里, 简单工厂的例子并不恰当, 而简单工厂和工厂方法居然用了两个实例, 真是扰乱视听, 让人糊涂. 但即便如此, 还是可以看出, 两者最大的区别: 抽象的维度. 简单工厂的抽象, 是一维的, 它抽象的仅仅是所创建”<strong>类型</strong>“的接口; 而工厂方法的抽象, 是二维的, 它不仅抽象了所创建”类型”的接口, 而且抽象了”<strong>方法</strong>“的接口.</p>
<p>具体到例子里, 简单工厂实例中, 客户就是要一个门, 而不关心创建过程, 最后实际创造的是一个木门. 这个颇为讽刺, 如果客户要的是个铁门呢? 那就事与愿违了. 所以在这个例子里, 也是存在两维抽象的.一是”门”这个类型的抽象, 二是”造门”这个方法的抽象. 简单工厂只做到了前者, 而没有给出后者的解决方案, 这才造成了客户可能吃了哑巴亏. 如果我们按照工厂方法的思路, 将门工厂造门这件事进行细分, 木门交给木门工厂, 铁门交给铁门工厂. 这就和工厂方法里的例子别无二致了. 客户需要先指定委托对象, 而不关心具体怎么造门:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DoorFactory* woodenDoorFactory = new WoodenDoorFactory();</span><br><span class="line">woodenDoorFactory-&gt;MakeDoor(100, 200);</span><br><span class="line"></span><br><span class="line">DoorFactory* ironDoorFactory = new IronDoorFactory();</span><br><span class="line">ironDoorFactory-&gt;MakeDoor(100, 200);</span><br></pre></td></tr></table></figure>
<p>这就成了工厂方法了. 所谓二维: “DoorFactory” 和 “MakeDoor”, 前者是无论委托给谁, 反正它是一个门工厂; 后者是管它造什么门, 反正它会给我造出一个 100*200 的门来. 客户不关心细节, 只关心结果. 这就使抽象的本质了. 第二个例子也是一样, “Interview” 和 “HiringManager” 是两维抽象, 客户要的是完成面试过程, 要的就是一个面试官. 至于找了谁来充当面试官, 进行的是什么方面的面试. 最终都是看不到的. 最后抽象成的结果就是: “面试官完成了面试”这么件事.</p>
<h3 id="🔨-抽象工厂"><a href="#🔨-抽象工厂" class="headerlink" title="🔨 抽象工厂"></a>🔨 抽象工厂</h3><p>真实案例:</p>
<blockquote>
<p>接着简单工厂里的案例. 根据实际需要, 您可以从木门商店获得木门, 从铁门商店获得铁门, 从相关商店获得 PVC 门. 除此之外, 你还需要不同专业的人, 来帮你装门, 木门需要木匠, 铁门需要焊工. 可以看到, 门之间存在着一定的对应依赖关系. 木门-木匠, 铁门-焊工, 等等.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>工厂们的工厂, 一家管理各自独立却又互相依赖的一批工厂, 而不关心各自的细节.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDescription() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WoodenDoor : public IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    void GetDescription() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;I am a wooden door&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IronDoor : public IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    void GetDescription() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;I am a iron door&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IDoorFittingExpert &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDescription() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Carpenter : public IDoorFittingExpert &#123;</span><br><span class="line">    void GetDescription() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;I can only fit wooden doors&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Welder : public IDoorFittingExpert &#123;</span><br><span class="line">    void GetDescription() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;I can only fit iron doors&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IDoorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IDoor* MakeDoor() = 0;</span><br><span class="line">    virtual IDoorFittingExpert* MakeFittingExpert() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Door, typename DoorFittingExpert&gt;</span><br><span class="line">class DoorFactory : public IDoorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">    IDoor* MakeDoor() override &#123;</span><br><span class="line">        return new Door();</span><br><span class="line">    &#125;</span><br><span class="line">    IDoorFittingExpert* MakeFittingExpert() override &#123;</span><br><span class="line">        return new DoorFittingExpert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IDoorFactory* woodenFactory = new DoorFactory&lt;WoodenDoor, Carpenter&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        IDoor* door = woodenFactory-&gt;MakeDoor();</span><br><span class="line">        IDoorFittingExpert* expert = woodenFactory-&gt;MakeFittingExpert();</span><br><span class="line">        door-&gt;GetDescription();</span><br><span class="line">        expert-&gt;GetDescription();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IDoorFactory* ironFactory = new DoorFactory&lt;IronDoor, Welder&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        IDoor* door = ironFactory-&gt;MakeDoor();</span><br><span class="line">        IDoorFittingExpert* expert = ironFactory-&gt;MakeFittingExpert();</span><br><span class="line">        door-&gt;GetDescription();</span><br><span class="line">        expert-&gt;GetDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用时机</strong>:</p>
<p>当遇到不那么简单的创建逻辑, 伴随着与之相关的依赖关系时.</p>
<p><strong>本质</strong>:</p>
<p>依然可以用维度来理解抽象工厂. 抽象工厂比工厂方法又多了一维. 我们再把三个工厂理一遍: 简单工厂, 是针对一种”类型”的抽象; 工厂方法, 是针对一种”类型”, 以及一种”创建方法”的抽象; 抽象工厂, 是针对<strong>一组</strong>“类型”与”创建方法”的抽象, 组内每一套类型与创建方法一一对应. 用造门这个例子来说: 简单工厂, 是封装了”造门”的操作, 输出的是一种门; 工厂方法, 是封装了”多种造门”的操作, 并委托”多家工厂”, 输出的是”各种门”. 抽象工厂, 是封装了”多种造门”的操作, “提供多种专业人员”的操作, 并委托给”多家工厂”, 输出的是”各种门”, 以及”各种专业人员”, 且”门”与”专业人员”一一对应.</p>
<p>例子中, 抽象工厂提供了两套”类型 - 创建操作”(分别是”门 - 造门”, “专业人员 - 提供专业人员”), 其实这个个数是无限的. 你可以提供 n 套这样的对应关系. 然后委托给相关的工厂. 这就是”工厂们的工厂”的具体含义.</p>
<h3 id="👷-生成器"><a href="#👷-生成器" class="headerlink" title="👷 生成器"></a>👷 生成器</h3><p>真实案例:</p>
<blockquote>
<p>假设你在哈迪斯(美国连锁快餐集团), 正想下单. 如果你说, 要一个 “大哈迪”, 他们很快就能交给你, 而不多问一句. 这是简单工厂的例子. 但, 当创建逻辑涉及更多步骤时, 譬如, 你在 Subway 买汉堡, 那么你可能需要做出更多选择, 想要哪种面包? 哪种酱汁? 哪种奶酪? 这种情况下, 就需要用到生成器模式了.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>允许你创建不同风格的对象, 同时避免构造器污染. 当对象有好几种口味的时候尤其有用. 或者是创建对象的过程涉及很多步骤时.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The builder pattern is an object creation software design pattern with the intentions of finding a solution to the telescoping constructor anti-pattern.</p>
</blockquote>
<p>简单说下”the telescoping constructor anti-pattern”(可伸缩构造器的反模式)是什么. 你总会看到下面这种构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Burger(int size, bool cheese = true, bool peperoni = true, bool tomato = false, bool lettuce = true);</span><br></pre></td></tr></table></figure>
<p>你应该已经察觉了, 构造函数的参数数量可能会迅速失控, 而且其参数安排会越来越难理解. 将来想要增加更多选项, 这个列表会一直增长下去. 这就被称为”the telescoping constructor anti-pattern”(可伸缩构造器的反模式).</p>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Burger &#123;</span><br><span class="line">public:</span><br><span class="line">    class BurgerBuilder;</span><br><span class="line">    void showFlavors() &#123;</span><br><span class="line">        std::cout &lt;&lt; size_;</span><br><span class="line">        if (cheese_) std::cout &lt;&lt; &quot;-cheese&quot;;</span><br><span class="line">        if (peperoni_) std::cout &lt;&lt; &quot;-peperoni&quot;;</span><br><span class="line">        if (lettuce_) std::cout &lt;&lt; &quot;-lettuce&quot;;</span><br><span class="line">        if (tomato_) std::cout &lt;&lt; &quot;-tomato&quot;;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Burger(int size): size_(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    int size_ = 7;</span><br><span class="line">    bool cheese_ = false;</span><br><span class="line">    bool peperoni_ = false;</span><br><span class="line">    bool lettuce_ = false;</span><br><span class="line">    bool tomato_ = false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Burger::BurgerBuilder &#123;</span><br><span class="line">public:</span><br><span class="line">    BurgerBuilder(int size) &#123; burger_ = new Burger(size); &#125;</span><br><span class="line">    BurgerBuilder&amp; AddCheese() &#123; burger_-&gt;cheese_ = true; return *this; &#125;</span><br><span class="line">    BurgerBuilder&amp; AddPepperoni() &#123; burger_-&gt;peperoni_ = true; return *this; &#125;</span><br><span class="line">    BurgerBuilder&amp; AddLettuce() &#123; burger_-&gt;lettuce_ = true; return *this; &#125;</span><br><span class="line">    BurgerBuilder&amp; AddTomato() &#123; burger_-&gt;tomato_ = true; return *this; &#125;</span><br><span class="line">    Burger* Build() &#123; return burger_; &#125;</span><br><span class="line">private:</span><br><span class="line">    Burger* burger_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Burger* burger = Burger::BurgerBuilder(14).AddPepperoni().AddLettuce().AddTomato().Build();</span><br><span class="line">    burger-&gt;showFlavors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码与原文代码略有不同, 但表达的主旨, 以及最终用法完全一致. (额外添加了输出函数, 方便运行查看)</p>
<p><strong>使用时机</strong>:</p>
<p>当对象拥有好几种口味, 且需要避免构造器伸缩时使用. 与工厂模式运用场景不同之处在于: 当创建过程仅仅一步到位, 使用工厂模式. 如果需要分步进行, 则考虑使用生成器模式.</p>
<p><strong>本质</strong>:</p>
<p>生成器模式的本质, 就是将构造函数中的参数列表<strong>方法化</strong>. 长长的参数列表, 无论是面向对象还是函数式编程, 都是大忌. 该模式主要就是为了解决该问题. 函数式编程中对该问题的解决方式是: <a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a>, 其本质与生成器模式是一样的.</p>
<h3 id="🐑-原型"><a href="#🐑-原型" class="headerlink" title="🐑 原型"></a>🐑 原型</h3><p>真实案例:</p>
<blockquote>
<p>还记得多利吗? 这个山羊是克隆的! 先不谈细节, 关键点都集中在于克隆上.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>通过克隆, 基于已有对象来创建对象.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.</p>
</blockquote>
<p>简言之, 它允许你拷贝一份已有对象, 并根据需求改造之. 从而省去了草创的过程.</p>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Sheep &#123;</span><br><span class="line">public:</span><br><span class="line">    Sheep(const std::string&amp; name, const std::string&amp; category = &quot;Mountain Sheep&quot;) : name_(name), category_(category) &#123;&#125;</span><br><span class="line">    void SetName(const std::string&amp; name) &#123; name_ = name; &#125;</span><br><span class="line">    void ShowInfo() &#123; std::cout &lt;&lt; name_ &lt;&lt; &quot; : &quot; &lt;&lt; category_ &lt;&lt; std::endl; &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string name_;</span><br><span class="line">    std::string category_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Sheep jolly(&quot;Jolly&quot;);</span><br><span class="line">    jolly.ShowInfo();</span><br><span class="line"></span><br><span class="line">    Sheep dolly(jolly); // copy constructor</span><br><span class="line">    dolly.SetName(&quot;Dolly&quot;);</span><br><span class="line">    dolly.ShowInfo();</span><br><span class="line"></span><br><span class="line">    Sheep doolly = jolly; // copy assignment</span><br><span class="line">    doolly.SetName(&quot;Doolly&quot;);</span><br><span class="line">    doolly.ShowInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码, 利用的是 <code>Sheep</code> 默认的拷贝构造和拷贝赋值函数, 当然也可也重写这两个函数实现自定义操作.</p>
<p><strong>使用时机</strong>:</p>
<p>当需要的对象, 与已存在的对象非常相似, 或当创建过程比克隆一下更费时的时候.</p>
<p><strong>本质</strong>:</p>
<p>原型模型, 基本已经嵌入在各种语言实现里了. 其核心就是 Copy. 其实这个策略不局限于代码架构, 当你重装完操作系统, 并安装了必备软件, 一般会打包一份 ghost, 下次给别人重装的时候, 直接一键 ghost 即可, 如有特殊需要, 可以装好后再调整. 这个过程实际上也是原型模式. 再比如, 我们开发时总会先搭建环境(脚手架), 现在可以用 docker 来搭建了, 那么你用别人的 docker 包来搭建时, 其实也时原型模式. 这样理解, 就比较通俗了.</p>
<h3 id="💍-单例"><a href="#💍-单例" class="headerlink" title="💍 单例"></a>💍 单例</h3><p>真实案例:</p>
<blockquote>
<p>所谓一山不容二虎, 一国不可两君. 遇到大事, 总应该由同一位老大来处理. 那么这位老大就是单例.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>确保一个特定类的一个对象, 只能创建一次.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.</p>
</blockquote>
<p>实际上, 单利模式常被认为是反模式, 要避免过度使用. 它本质上类似全局变量, 可能会造成耦合度过高的问题, 也可能给调试带来困难. 故而一定要谨慎使用.</p>
<p><strong>示例代码</strong>:</p>
<p>创造单例, 要确保构造函数私有化, 拷贝构造, 拷贝赋值应该禁用. 创建一个静态变量来存此单例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line"></span><br><span class="line">class President &#123;</span><br><span class="line">public:</span><br><span class="line">    static President&amp; GetInstance() &#123;</span><br><span class="line">        static President instance;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    President(const President&amp;) = delete;</span><br><span class="line">    President&amp; operator=(const President&amp;) = delete;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    President() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const President&amp; president1 = President::GetInstance();</span><br><span class="line">    const President&amp; president2 = President::GetInstance();</span><br><span class="line"></span><br><span class="line">    assert(&amp;president1 == &amp;president2); // same address, point to same object.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>简言之:</p>
<blockquote>
<p>结构型模式重点关注对象组合, 换句话说, 实体如何互相调用. 还有另一个解释: 对”如何构建一个软件组件?”问题的回答.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities.</p>
</blockquote>
<ul>
<li><a>适配器</a></li>
<li><a>桥接</a></li>
<li><a>组成</a></li>
<li><a>装饰</a></li>
<li><a>外观</a></li>
<li><a>享元</a></li>
<li><a>代理</a></li>
</ul>
<h3 id="🔌-适配器"><a href="#🔌-适配器" class="headerlink" title="🔌 适配器"></a>🔌 适配器</h3><p>真实案例:</p>
<blockquote>
<p>三个例子: 1) 你从相机存储卡传照片给电脑, 需要与此兼容的适配器, 来保证连接. 2) 电源适配器, 三脚插头转两脚插头. 3) 翻译, 看好莱坞大片, 将英文字幕转为中文.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>适配器模式, 包装一个对象, 让本不兼容其他类的该对象变得兼容.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class ILion &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Roar() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;I am a Lion&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Hunter &#123;</span><br><span class="line">public:</span><br><span class="line">    void Hunt(ILion&amp; lion) &#123;</span><br><span class="line">        lion.Roar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WildDog</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Bark() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;I am a wild dog.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//! now we added a new class `WildDog`, the hunter can hunt it also.</span><br><span class="line">//! But we cannot do that directly because dog has a different interface.</span><br><span class="line">//! To make it compatible for our hunter, we will have to create an adapter.</span><br><span class="line"></span><br><span class="line">class WildDogAdapter : public ILion &#123;</span><br><span class="line">public:</span><br><span class="line">    WildDogAdapter(WildDog&amp; dog): dog_(dog) &#123;&#125;</span><br><span class="line">    void Roar() override &#123;</span><br><span class="line">        dog_.Bark();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    WildDog&amp; dog_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    WildDog dog;</span><br><span class="line">    WildDogAdapter dogAdapter(dog);</span><br><span class="line"></span><br><span class="line">    Hunter hunter;</span><br><span class="line">    hunter.Hunt(dogAdapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>软工领域, 很多问题都可以用<strong>在中间加一层</strong>的方式来解决. 适配器模式, 是这种策略的典型应用之一.</p>
<h3 id="🚡-桥接"><a href="#🚡-桥接" class="headerlink" title="🚡 桥接"></a>🚡 桥接</h3><p>真实案例:</p>
<blockquote>
<p>如果你有一个网站, 有着很多不同种类的页面. 而此刻你有一个功能是允许用户来改变主题样式. 该怎么做? 为每个不同页面都创建多个副本? 还是创建单独的主题, 并根据用户偏好加载它们? 桥接模式允许你实现第二种方案.</p>
</blockquote>
<p>一图胜千言:</p>
<p>简言之:</p>
<blockquote>
<p>桥接模式, 优先考虑组合而非继承. 将实现细节从层次结构中, 剥离并独立成另一套层次结构.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The bridge pattern is a design pattern used in software engineering that is meant to “decouple an abstraction from its implementation so that the two can vary independently”</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class ITheme &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual std::string GetColor() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DarkTheme : public ITheme &#123;</span><br><span class="line">public:</span><br><span class="line">    std::string GetColor() override &#123; return &quot;Dark Black&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LightTheme : public ITheme &#123;</span><br><span class="line">public:</span><br><span class="line">    std::string GetColor() override &#123; return &quot;Off white&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AquaTheme : public ITheme &#123;</span><br><span class="line">public:</span><br><span class="line">    std::string GetColor() override &#123; return &quot;Light blue&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IWebPage &#123;</span><br><span class="line">public:</span><br><span class="line">    IWebPage(ITheme&amp; theme) : theme_(theme) &#123;&#125;</span><br><span class="line">    virtual std::string GetContent() = 0;</span><br><span class="line">protected:</span><br><span class="line">    ITheme&amp; theme_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class About : public IWebPage &#123;</span><br><span class="line">public:</span><br><span class="line">    About(ITheme&amp; theme) : IWebPage(theme) &#123;&#125;</span><br><span class="line">    std::string GetContent() override &#123;</span><br><span class="line">        return &quot;About page in &quot; + theme_.GetColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Careers : public IWebPage &#123;</span><br><span class="line">public:</span><br><span class="line">    Careers(ITheme&amp; theme) : IWebPage(theme) &#123;&#125;</span><br><span class="line">    std::string GetContent() override &#123;</span><br><span class="line">        return &quot;Careers page in &quot; + theme_.GetColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DarkTheme darkTheme;</span><br><span class="line">    About about(darkTheme);</span><br><span class="line">    Careers careers(darkTheme);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; about.GetContent() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; careers.GetContent() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>桥接模式本质上是一种拆分. 讲适配器模式的时候, 我提过一句行内名言: “很多(任何)问题都可以通过在中间加一层的方式解决”. 这个可以理解成”加”操作. 那么桥接模式, 实际上是一种”减”操作. 而对应着另一句话: “面对混乱, 难以维护的代码, 第一步要做的就是拆”. 怎么拆? 桥接模式讲究在一种层次结构中剥离出另一套独立的层次结构. 譬如这个例子中, “Theme”就是剥离出来的抽象概念. 玻璃之前, 页面一大堆, 但是有规律: 很多页面, 只是样式不同, 但内容相同. 怎么做? DRY 原则告诉我们, 相同的东西保留一份, 将不同的东西抽象出来. 这也与 “高内聚, 低耦合” 这个最终目的一脉相承.抽出 Theme 之后, 剩下的 Page 部分, 内聚就比较高了, 也可以称之为: 更加纯粹了, 只负责页面内容.</p>
<p>还要注意到适配器和桥接模式的相同点, 它们都存在一个强耦合的<strong>关联</strong>(UML)关系. 譬如 <code>WildDogAdapter</code> 就必然包含一个 <code>WildDog</code> (<strong>组合</strong>(UML)关系). <code>IWebPage</code> 就必然包含一个 <code>ITheme</code>(也是<strong>组合</strong>(UML)关系). 而从这个角度来看, 你发现桥接里, 这种关系发生在接口层面, 而适配器, 只是简单的发生在两个类层面. 这就好比简单工厂与工厂方法的关系. 是维度的上升, 而多出的这个维度, 就是桥接模式中”层次”的体现.</p>
<h3 id="🌿-组成"><a href="#🌿-组成" class="headerlink" title="🌿 组成"></a>🌿 组成</h3><p>真实案例:</p>
<blockquote>
<p>每个公司都是由员工组成的. 每个员工, 有相同点: 如都有薪水, 都需要负责, 都可能有上级, 也都可能有下属.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>组合模式让客户以统一的方式对待各个独立的对象.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes that a group of objects is to be treated in the same way as a single instance of an object. The intent of a composite is to “compose” objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    Employee(const std::string&amp; name, float salary): name_(name), salary_(salary) &#123;&#125;</span><br><span class="line">    virtual std::string GetName() &#123; return name_; &#125;</span><br><span class="line">    virtual float GetSalary() &#123; return salary_; &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    float salary_;</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Developer : public Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    Developer(const std::string&amp; name, float salary) : Employee(name, salary) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Designer : public Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    Designer(const std::string&amp; name, float salary) : Employee(name, salary) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Organization &#123;</span><br><span class="line">public:</span><br><span class="line">    void AddEmployee(const Employee&amp; employee) &#123;</span><br><span class="line">        employees_.push_back(employee);</span><br><span class="line">    &#125;</span><br><span class="line">    float GetNetSalaries() &#123;</span><br><span class="line">        float net_salary = 0;</span><br><span class="line">        for (auto&amp;&amp; employee : employees_) &#123;</span><br><span class="line">            net_salary += employee.GetSalary();</span><br><span class="line">        &#125;</span><br><span class="line">        return net_salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;Employee&gt; employees_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Developer john(&quot;John Doe&quot;, 12000);</span><br><span class="line">    Designer jane(&quot;Jane Doe&quot;, 15000);</span><br><span class="line"></span><br><span class="line">    Organization org;</span><br><span class="line">    org.AddEmployee(john);</span><br><span class="line">    org.AddEmployee(jane);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Net salaries: &quot; &lt;&lt; org.GetNetSalaries() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>组合模式在我看来甚至称不上什么模式, 其核心就是<strong>多态</strong>特性的体现. 另一个核心在于, 容器存储的是接口类型, 利用多态, 可以迭代处理通用操作.</p>
<h3 id="☕-装饰"><a href="#☕-装饰" class="headerlink" title="☕ 装饰"></a>☕ 装饰</h3><p>真实案例:</p>
<blockquote>
<p>假设你经营一家提供多种服务的汽车服务店. 你如何来计算收费账单? 通常会选择一项服务的同时, 动态更新服务的总价. 这里, 每一种服务都是装饰器.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>装饰模式将对象包装在装饰类对象中, 从而在运行时动态改变该对象的行为.</p>
</blockquote>
<p>Wikipedia：</p>
<blockquote>
<p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class ICoffee &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual float GetCost() = 0;</span><br><span class="line">    virtual std::string GetDescription() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SimpleCoffee : public ICoffee &#123;</span><br><span class="line">public:</span><br><span class="line">    float GetCost() override &#123; return 10; &#125;</span><br><span class="line">    std::string GetDescription() override &#123; return &quot;Simple coffee&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CoffeePlus : public ICoffee &#123;</span><br><span class="line">public:</span><br><span class="line">    CoffeePlus(ICoffee&amp; coffee): coffee_(coffee) &#123;&#125;</span><br><span class="line">    virtual float GetCost() = 0;</span><br><span class="line">    virtual std::string GetDescription() = 0;</span><br><span class="line">protected:</span><br><span class="line">    ICoffee&amp; coffee_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MilkCoffee : public CoffeePlus &#123;</span><br><span class="line">public:</span><br><span class="line">    MilkCoffee(ICoffee&amp; coffee): CoffeePlus(coffee) &#123;&#125;</span><br><span class="line">    float GetCost() override &#123; return coffee_.GetCost() + 2; &#125;</span><br><span class="line">    std::string GetDescription() override &#123; return coffee_.GetDescription() + &quot;, milk&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WhipCoffee : public CoffeePlus &#123;</span><br><span class="line">public:</span><br><span class="line">    WhipCoffee(ICoffee&amp; coffee): CoffeePlus(coffee) &#123;&#125;</span><br><span class="line">    float GetCost() override &#123; return coffee_.GetCost() + 5; &#125;</span><br><span class="line">    std::string GetDescription() override &#123; return coffee_.GetDescription() + &quot;, whip&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VanillaCoffee : public CoffeePlus &#123;</span><br><span class="line">public:</span><br><span class="line">    VanillaCoffee(ICoffee&amp; coffee): CoffeePlus(coffee) &#123;&#125;</span><br><span class="line">    float GetCost() override &#123; return coffee_.GetCost() + 3; &#125;</span><br><span class="line">    std::string GetDescription() override &#123; return coffee_.GetDescription() + &quot;, vanilla&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ICoffee* someCoffee = new SimpleCoffee();</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetCost() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetDescription() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    someCoffee = new MilkCoffee(*someCoffee);</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetCost() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetDescription() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    someCoffee = new WhipCoffee(*someCoffee);</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetCost() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetDescription() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    someCoffee = new VanillaCoffee(*someCoffee);</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetCost() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; someCoffee-&gt;GetDescription() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>装饰模式的形态很有意思, 像是静态语言的动态化. 其实实现上与组合模式类似, 但关键之处在于, 其<strong>依赖的对象是其父类接口</strong>. 顾名思义, 装饰模式, 装饰的是对象自身, 且支持重复装饰. 譬如上述实例中, 完全可以加两遍牛奶. 但最终要保证接口的一致性, 就像你的房子无论装饰成什么样子, 它依然只是你的房子.</p>
<h3 id="📦-外观"><a href="#📦-外观" class="headerlink" title="📦 外观"></a>📦 外观</h3><p>真实案例:</p>
<blockquote>
<p>如何开机? 你会说”按一下电源键”. 你会有这样的反应, 是因为计算机提供了一个超级简单的接口, 而隐藏了一系列复杂的开机操作所致. 这个简单接口, 对于复杂操作来说, 就是外观.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>外观模式为复杂的子系统提供了一个简单接口.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>A facade is an object that provides a simplified interface to a larger body of code, such as a class library.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Computer &#123;</span><br><span class="line">public:</span><br><span class="line">    void GetElectricShock() &#123; std::cout &lt;&lt; &quot;Ouch!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void MakeSound() &#123; std::cout &lt;&lt; &quot;Beep beep!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void ShowLoadingScreen() &#123; std::cout &lt;&lt; &quot;Loading...&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Bam() &#123; std::cout &lt;&lt; &quot;Ready to be used!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void CloseEverything() &#123; std::cout &lt;&lt; &quot;Bup bup bup buzzzz!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Sooth() &#123; std::cout &lt;&lt; &quot;Zzzzz&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void PullCurrent() &#123; std::cout &lt;&lt; &quot;Haaah!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ComputerFacade &#123;</span><br><span class="line">public:</span><br><span class="line">    ComputerFacade(Computer&amp; computer): computer_(computer) &#123;&#125;</span><br><span class="line">    void TurnOn() &#123;</span><br><span class="line">        computer_.GetElectricShock();</span><br><span class="line">        computer_.MakeSound();</span><br><span class="line">        computer_.ShowLoadingScreen();</span><br><span class="line">        computer_.Bam();</span><br><span class="line">    &#125;</span><br><span class="line">    void TurnOff() &#123;</span><br><span class="line">        computer_.CloseEverything();</span><br><span class="line">        computer_.PullCurrent();</span><br><span class="line">        computer_.Sooth();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Computer&amp; computer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Computer real_computer;</span><br><span class="line">    ComputerFacade computer(real_computer);</span><br><span class="line">    computer.TurnOn();</span><br><span class="line">    computer.TurnOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>同样很难称之为模式的模式. 用的依然是”多加一层”的思想, 通过封装的方式来实现. 多的这一层, 就是所谓的”外观”了.</p>
<h3 id="🍃-享元"><a href="#🍃-享元" class="headerlink" title="🍃 享元"></a>🍃 享元</h3><p>真实案例:</p>
<blockquote>
<p>你有没有在摊位边喝现泡茶的体验? 他们经常除了你要求的这一杯外, 还额外沏更多的茶, 留给其他的潜在客户. 以此来节省资源, 包括热气, 火候等. 享元模式就是针对这一特点的: 共享.</p>
</blockquote>
<p>简言之:</p>
<p>通常以最小的存储用量或计算成本为代价, 共享给尽可能多的相似对象.</p>
<p>Wikipedia:</p>
<blockquote>
<p>In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory use by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">// Anything that will be cached is flyweight.</span><br><span class="line">// Types of tea here will be flyweights.</span><br><span class="line">class KarakTea &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class TeaMaker &#123;</span><br><span class="line">public:</span><br><span class="line">    KarakTea* Make(const std::string&amp; preference) &#123;</span><br><span class="line">        if (availableTea_.find(preference) == availableTea_.end())</span><br><span class="line">            availableTea_.insert(&#123;preference, new KarakTea()&#125;);</span><br><span class="line"></span><br><span class="line">        return availableTea_.at(preference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::unordered_map&lt;std::string, KarakTea*&gt; availableTea_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TeaShop &#123;</span><br><span class="line">public:</span><br><span class="line">    TeaShop(TeaMaker&amp; teaMaker): teaMaker_(teaMaker) &#123;&#125;</span><br><span class="line">    void TakeOrder(const std::string&amp; teaType, int table) &#123;</span><br><span class="line">        orders_[table] = teaMaker_.Make(teaType);</span><br><span class="line">    &#125;</span><br><span class="line">    void Serve() &#123;</span><br><span class="line">        for(auto order : orders_)</span><br><span class="line">            std::cout &lt;&lt; &quot;Serving tea to table# &quot; &lt;&lt; order.first &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::unordered_map&lt;int, KarakTea*&gt; orders_;</span><br><span class="line">    TeaMaker&amp; teaMaker_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    TeaMaker teaMaker;</span><br><span class="line">    TeaShop shop(teaMaker);</span><br><span class="line"></span><br><span class="line">    shop.TakeOrder(&quot;less sugar&quot;, 1);</span><br><span class="line">    shop.TakeOrder(&quot;more milk&quot;, 2);</span><br><span class="line">    shop.TakeOrder(&quot;without sugar&quot;, 5);</span><br><span class="line"></span><br><span class="line">    shop.Serve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>享元模式的本质就是最基本的<strong>缓存</strong>思想, 无论是计算机体系结构中的 cache 还是操作系统中的 page table, 都是这种思想的体现. 在程序设计中, 实现这一思想, 最常用的数据结构就是哈希表. 如例子中所示. 其最简单的用法描述就是: key 存在了, 直接取走; 不存在, 创建一个. 以此节省重复的创建与冗余的空间.</p>
<h3 id="🎱-代理"><a href="#🎱-代理" class="headerlink" title="🎱 代理"></a>🎱 代理</h3><p>真实案例:</p>
<blockquote>
<p>你应该用过门禁卡开门吧? 其实有很多种方式来开门, 如用门禁卡, 或是输入安全密码等等. 门的主要功能本来只是”开”, 而现在门禁系统就像是加之于门的代理, 使之拥有了更多的功能. 下面的示例代码会更好的阐述这一思路.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>使用代理模式, 一个类会表现出另一个类的功能.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>A proxy, in its most general form, is a class functioning as an interface to something else. A proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Open() = 0;</span><br><span class="line">    virtual void Close() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LabDoor : public IDoor &#123;</span><br><span class="line">public:</span><br><span class="line">    void Open() override &#123; std::cout &lt;&lt; &quot;Opening lab door&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Close() override &#123; std::cout &lt;&lt; &quot;Closing the lab door&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Security &#123;</span><br><span class="line">public:</span><br><span class="line">    Security(IDoor&amp; door): door_(door) &#123;&#125;</span><br><span class="line">    bool Authenticate(const std::string&amp; password) &#123; return password == &quot;$ecr@t&quot;; &#125;</span><br><span class="line">    void Open(const std::string&amp; password) &#123;</span><br><span class="line">        if (Authenticate(password)) door_.Open();</span><br><span class="line">        else std::cout &lt;&lt; &quot;Big no! It ain&apos;t possible.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Close() &#123; door_.Close(); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    IDoor&amp; door_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LabDoor labDoor;</span><br><span class="line">    Security securityDoor(labDoor);</span><br><span class="line">    securityDoor.Open(&quot;invalid&quot;);</span><br><span class="line">    securityDoor.Open(&quot;$ecr@t&quot;);</span><br><span class="line">    securityDoor.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子是一些数据映射的实现. 例如, 我最近为 MongoDB 做了一个 ODM (对象数据映射), 使用的就是这个模式: 我用魔术方法 <code>_call()</code> 给 MongoDB 的类加了一个代理. 所有方法通过代理, 实际都会调用 MongoDB 类的方法, 并返回其调用结果. 但我增加了两个特例: <code>find</code> 和 <code>findOne</code> 方法查询数据时, 会被映射到相应的对象, 并返回该对象. 而不再是返回 <code>Cursor</code> 了.</p>
<p><strong>本质</strong>:</p>
<p>依然体现了<strong>加一层</strong>的思想, 这与上面遇到的<a>适配器模式</a>和<a>外观模式</a>都很类似. 这里我们先比较一下三者的差别: 适配器的目的很明确, 是为了适应已有接口, 出发点是兼容; 外观模式的目的是简化繁琐的接口, 出发点是封装; 而代理模式的目的是增加更多功能, 出发点也是兼容. 但代理模式的兼容, 与适配器有很大差别, 适配器是真的从接口上兼容, 继承同样的接口类, 实现父类的虚方法; 代理模式则不然, 它的兼容, 更像是一种<strong>伪装</strong>, 只是接口的名称保持一致, 但实际上并无多大关联. 譬如例子里, 以前你用门, 有 <code>Open</code> 和 <code>Close</code> 方法, 现在换成安全门了, 你依然习惯性的想用这两种方法. 然而安全门只是门的代理, 所以它的这两种同名方法, 其实是伪造给你看的, 与之前的方法并无接口上的兼容性.</p>
<p>代理模式广泛使用在 API 设计中, 其核心是为了兼容用户习惯.</p>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>简言之:</p>
<blockquote>
<p>关注对象间的责任分配. 它们与结构模式最大的不同在于: 它们不仅仅指定结构, 还概述了结构之间<strong>消息传递/通讯的模式</strong>. 换句话说, 它们回答了”软件组件们的行为是如何运转的”这个问题.</p>
</blockquote>
<p>Wikipadia:</p>
<blockquote>
<p>In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication.</p>
</blockquote>
<ul>
<li><a>责任链</a></li>
<li><a>命令</a></li>
<li><a>迭代器</a></li>
<li><a>中介者</a></li>
<li><a>备忘录</a></li>
<li><a>观察者</a></li>
<li><a>访问者</a></li>
<li><a>策略</a></li>
<li><a>状态</a></li>
<li><a>模板方法</a></li>
</ul>
<h3 id="🔗-责任链"><a href="#🔗-责任链" class="headerlink" title="🔗 责任链"></a>🔗 责任链</h3><p>真实案例:</p>
<blockquote>
<p>假设, 您的账户里有三种付款方式可供选择(A, B 和 C). 但额度各不一样, A 有 100$, B 有 300$, C 有 1000$. 支付优先级顺序是从 A 到 C. 当您尝试购买价格为 210$ 的东西时, 用责任链来处理, 会先去看 A 方式可否搞定, 如果搞不定, 就再去用 B, 如果依然搞不定, 再去用 C. 直到找到合适的方式. 这里的 A, B 和 C 构成的链条, 以及这样的现象就是责任链.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>它有助于建立一条对象链. 请求会从一端开始, 依次访问对象, 直到找到合适的处理程序.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Account &#123;</span><br><span class="line">public:</span><br><span class="line">    Account(float balance) : balance_(balance) &#123;&#125;</span><br><span class="line">    virtual std::string GetClassName() &#123; return &quot;Account&quot;; &#125;</span><br><span class="line">    void SetNext(Account* const account) &#123; successor_ = account; &#125;</span><br><span class="line">    bool CanPay(float amount) &#123; return balance_ &gt;= amount; &#125;</span><br><span class="line">    void Pay(float amountToPay) &#123;</span><br><span class="line">        if (CanPay(amountToPay)) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Paid &quot; &lt;&lt; amountToPay &lt;&lt; &quot; using &quot; &lt;&lt; GetClassName() &lt;&lt; std::endl;</span><br><span class="line">        &#125; else if (successor_) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Cannot pay using &quot; &lt;&lt; GetClassName() &lt;&lt; &quot;. Proceeding...&quot; &lt;&lt; std::endl;</span><br><span class="line">            successor_-&gt;Pay(amountToPay);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw &quot;None of the accounts have enough balance.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    Account* successor_ = nullptr;</span><br><span class="line">    float balance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Bank : public Account &#123;</span><br><span class="line">public:</span><br><span class="line">    Bank(float balance) : Account(balance) &#123;&#125;</span><br><span class="line">    std::string GetClassName() override &#123; return &quot;Bank&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Paypal : public Account &#123;</span><br><span class="line">public:</span><br><span class="line">    Paypal(float balance) : Account(balance) &#123;&#125;</span><br><span class="line">    std::string GetClassName() override &#123; return &quot;Paypal&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Bitcoin : public Account &#123;</span><br><span class="line">public:</span><br><span class="line">    Bitcoin(float balance) : Account(balance) &#123;&#125;</span><br><span class="line">    std::string GetClassName() override &#123; return &quot;Bitcoin&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //! Let&apos;s prepare a chain like below:</span><br><span class="line">    //! bank -&gt; paypal -&gt; bitcoin</span><br><span class="line">    //! First priority bank</span><br><span class="line">    //!   If bank can&apos;t pay then paypal</span><br><span class="line">    //!   If paypal can&apos;t pay then bit coin</span><br><span class="line"></span><br><span class="line">    Bank bank(100); //&gt; Bank with balance 100</span><br><span class="line">    Paypal paypal(200); //&gt; Paypal with balance 200</span><br><span class="line">    Bitcoin bitcoin(300); //&gt; Bitcoin with balance 300</span><br><span class="line"></span><br><span class="line">    bank.SetNext(&amp;paypal);</span><br><span class="line">    paypal.SetNext(&amp;bitcoin);</span><br><span class="line"></span><br><span class="line">    bank.Pay(259);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>责任链的本质其实是对象的<strong>单链表</strong>实现 + 对单链表的<strong>迭代</strong>. 上述例子中, 我们的迭代其实是接近<strong>递归</strong>的形式. 如果我们将整个责任链以统一的借口(<code>Account</code>)存储在 <code>list</code> 或 <code>vector</code> 中, 然后用 for 循环来迭代访问. 也同样可称为责任链. 所以不要被名词吓唬住, 始终回归到最基本的思想, 以及最基本的数据结构与逻辑手段. 这样才可以灵活应用.</p>
<h3 id="👮-命令"><a href="#👮-命令" class="headerlink" title="👮 命令"></a>👮 命令</h3><p>真实案例:</p>
<blockquote>
<p>一个典型的例子是, 在饭馆点菜. 你(客户)要求服务员(调用者)上一些食物(命令), 然后服务员将命令简短的传达给厨师(接收者), 厨师拥有做菜的必要知识与技能. 另一个例子, 你(客户)用遥控器(调用者)来切换(命令)电视(接收者)节目.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>允许你将操作封装在对象中. 这种模式背后的核心思想是分离客户与接收者.</p>
</blockquote>
<p>Wikipadia:</p>
<blockquote>
<p>In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Bulb &#123;</span><br><span class="line">  public:</span><br><span class="line">    void TurnOn() &#123; std::cout &lt;&lt; &quot;Bulb has been lit&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void TurnOff() &#123; std::cout &lt;&lt; &quot;Darkness!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ICommand &#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual void Execute() = 0;</span><br><span class="line">    virtual void Undo() = 0;</span><br><span class="line">    virtual void Redo() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TurnOn : public ICommand &#123;</span><br><span class="line">  public:</span><br><span class="line">    TurnOn(Bulb&amp; bulb): bulb_(bulb) &#123;&#125;</span><br><span class="line">    void Execute() override &#123; bulb_.TurnOn(); &#125;</span><br><span class="line">    void Undo() override &#123; bulb_.TurnOff(); &#125;</span><br><span class="line">    void Redo() override &#123; Execute(); &#125;</span><br><span class="line">  private:</span><br><span class="line">    Bulb&amp; bulb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TurnOff : public ICommand &#123;</span><br><span class="line">  public:</span><br><span class="line">    TurnOff(Bulb&amp; bulb): bulb_(bulb) &#123;&#125;</span><br><span class="line">    void Execute() override &#123; bulb_.TurnOff(); &#125;</span><br><span class="line">    void Undo() override &#123; bulb_.TurnOn(); &#125;</span><br><span class="line">    void Redo() override &#123; Execute(); &#125;</span><br><span class="line">  private:</span><br><span class="line">    Bulb&amp; bulb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RemoteControl &#123;</span><br><span class="line">  public:</span><br><span class="line">    void Submit(ICommand&amp; command) &#123; command.Execute(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Bulb bulb;</span><br><span class="line">  TurnOn turnOn(bulb);</span><br><span class="line">  TurnOff turnOff(bulb);</span><br><span class="line"></span><br><span class="line">  RemoteControl remote;</span><br><span class="line">  remote.Submit(turnOn);</span><br><span class="line">  remote.Submit(turnOff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令模式通常被用来实现交易基础系统, 当你执行一系列命令的同时维系一个历史记录. 如果最终命令执行成功就罢了, 若不成功, 将通过历史回溯, 来撤销这一系列命令.(这更像是一个原子命令的执行过程, 请见<a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a>)</p>
<p><strong>本质</strong>:</p>
<p>命令模式本质上, 是对<strong>消息协议的一种抽象</strong>, 而用的手法是<strong>回调</strong>. 就像举出的例子里, 提出要求的是客户, 执行要求的是厨师, 而连接两者的是服务员, 但真正连接者是消息的接口, 这个就是命令. 同样的, 电视机遥控器也是命令. 这个命令一定具备”简单”, “高粒度”等特点. 通常在运用的时候, 会加上对这个命令的历史记录与回溯. 也就是示例代码中的那三个基本接口: <code>execute</code>, <code>undo</code>, <code>redo</code>. 值得注意的是, <code>execute</code> 一定是 ACID 的, 通常会是包含一系列命令的集合. 一旦有一个命令执行失败, 那么会整体回滚.</p>
<h3 id="➿-迭代器"><a href="#➿-迭代器" class="headerlink" title="➿ 迭代器"></a>➿ 迭代器</h3><p>真实案例:</p>
<blockquote>
<p>老式的收音机是迭代器的一个好例子, 用户可以从任意频道开始, 通过点击”下一个”或”上一个”按钮, 来浏览响应的频道. 也可以用 MP3 播放器和电视机来举例, 你同样可以通过”向前”和”向后”按钮来连续切换频道. 换句话说, 它们都提供了一个接口来遍历各个频道, 歌曲或电台.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>它呈现了一种访问对象元素, 却不暴露底层方法的方式.</p>
</blockquote>
<p>Wikipadia:</p>
<blockquote>
<p>In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container’s elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">class RadioStation &#123;</span><br><span class="line">  friend bool operator==(const RadioStation&amp; lhs, const RadioStation&amp; rhs) &#123; return lhs.frequency_ == rhs.frequency_; &#125;</span><br><span class="line">public:</span><br><span class="line">  RadioStation(float frequency): frequency_(frequency) &#123;&#125;</span><br><span class="line">  float GetFrequency() const &#123; return frequency_; &#125;</span><br><span class="line">private:</span><br><span class="line">  float frequency_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class StationList &#123;</span><br><span class="line">  using Iter = std::vector&lt;RadioStation&gt;::iterator;</span><br><span class="line">public:</span><br><span class="line">  void AddStation(const RadioStation&amp; station) &#123; stations_.push_back(station); &#125;</span><br><span class="line">  void RemoveStation(const RadioStation&amp; toRemove) &#123;</span><br><span class="line">    auto found = std::find(stations_.begin(), stations_.end(), toRemove);</span><br><span class="line">    if (found != stations_.end()) stations_.erase(found);</span><br><span class="line">  &#125;</span><br><span class="line">  Iter begin() &#123; return stations_.begin(); &#125;</span><br><span class="line">  Iter end() &#123; return stations_.end(); &#125;</span><br><span class="line">private:</span><br><span class="line">  std::vector&lt;RadioStation&gt; stations_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  StationList stationList;</span><br><span class="line">  stationList.AddStation(RadioStation(89));</span><br><span class="line">  stationList.AddStation(RadioStation(101));</span><br><span class="line">  stationList.AddStation(RadioStation(102));</span><br><span class="line">  stationList.AddStation(RadioStation(103.2));</span><br><span class="line"></span><br><span class="line">  for (auto&amp;&amp; station : stationList)</span><br><span class="line">    std::cout &lt;&lt; station.GetFrequency() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  stationList.RemoveStation(RadioStation(89)); // Will remove station 89</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>同样称不上模式的模式. 这里的迭代器与 C++ 中迭代器的概念完全相同. 我觉得是否将语言中本有的容器包装成对象, 要适当取舍. 切莫为了设计而设计. 就示例代码而言, <code>StationList</code> 对象完全多此一举, 裸用容器就可以解决. 在实际应用中, 除非为了接口上的统一, 而使用一个代理(<code>StationList</code> 就是一个代理类), 否则完全不用过度设计. 迭代器的本质, 就是迭代. 这是程序语言最基础的一环, 所谓迭代器模式, 仅仅是这一环在面向对象中的体现.</p>
<h3 id="👽-中介者"><a href="#👽-中介者" class="headerlink" title="👽 中介者"></a>👽 中介者</h3><p>真实案例:</p>
<blockquote>
<p>典型案例是, 你通过手机给人打电话, 你和对方的通讯并非直接送达的, 而是需要通过中间的网络运营商. 这个案例中, 网络运营商就是中介者.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>中介者模式增加了一个第三方对象(中介者)来控制两个对象(同事)间的交互. 有助于对彼此通信的解耦, 毕竟他们并不需要关心对方的实现细节.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact. This pattern is considered to be a behavioral pattern due to the way it can alter the program’s running behavior.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">class User;</span><br><span class="line"></span><br><span class="line">class IChatRoomMediator &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void ShowMessage(const User&amp; user, const std::string&amp; message) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ChatRoom : public IChatRoomMediator &#123;</span><br><span class="line">public:</span><br><span class="line">    void ShowMessage(const User&amp; user, const std::string&amp; message) override;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">    User(const std::string&amp; name, IChatRoomMediator&amp; chatMediator): name_(name), chatMediator_(chatMediator) &#123;&#125;</span><br><span class="line">    const std::string&amp; GetName() const &#123; return name_; &#125;</span><br><span class="line">    void Send(const std::string&amp; message) &#123; chatMediator_.ShowMessage(*this, message); &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string name_;</span><br><span class="line">    IChatRoomMediator&amp; chatMediator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ChatRoom::ShowMessage(const User &amp;user, const std::string &amp;message) &#123;</span><br><span class="line">    std::time_t now = std::time(nullptr);</span><br><span class="line">    std::cout &lt;&lt; std::put_time(std::localtime(&amp;now), &quot;%Y-%m-%d %H:%M:%S&quot;) &lt;&lt; &quot;[&quot; &lt;&lt; user.GetName() &lt;&lt; &quot;]: &quot; &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ChatRoom mediator;</span><br><span class="line">    User john(&quot;John Doe&quot;, mediator);</span><br><span class="line">    User jane(&quot;Jane Doe&quot;, mediator);</span><br><span class="line">    john.Send(&quot;Hi, there!&quot;);</span><br><span class="line">    jane.Send(&quot;Hey!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>中介者的本质, 也是对<strong>消息协议的一种抽象</strong>, 并同样借用了<strong>回调</strong>的手段. 听起来和<a>命令</a>模式很类似, 其实也的确很类似. 区别仅在于业务场景的适应上: 命令模式适用于<strong>多种</strong>消息协议, 并将每一种都封装成对象, 是一种平铺式的抽象方式, 你通过多种命令, 来实现多种通讯; 中介者模式呢, 则固定为<strong>某一种</strong>消息协议, 同事之间要遵循相同的协议, 才可以做到通讯. 而这一种, 可以通过继承来具化, 所以是一种纵深式的抽象, 你和对方通讯, 可以是电话, 邮件, 微信等等, 但他们扮演的都是中介者这个角色.</p>
<h3 id="💾-备忘录"><a href="#💾-备忘录" class="headerlink" title="💾 备忘录"></a>💾 备忘录</h3><p>真实案例:</p>
<blockquote>
<p>以计算器(原发器)为例, 当你做了一组运算后, 最后一次计算过程会保存在内存(备忘录)中. 所以你随时可以通过某个按钮(负责人)来恢复该操作.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>备忘录模式会抓取并储存对象的当前状态, 之后可便捷的恢复出来.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The memento pattern is a software design pattern that provides the ability to restore an object to its previous state (undo via rollback).</p>
</blockquote>
<p>当你需要快照-恢复这样类似功能时, 该模式将会非常有用.</p>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class EditorMemento &#123;</span><br><span class="line">public:</span><br><span class="line">    EditorMemento(const std::string&amp; content): content_(content) &#123;&#125;</span><br><span class="line">    const std::string&amp; GetContent() const &#123; return content_; &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string content_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Editor &#123;</span><br><span class="line">    using MementoType = std::shared_ptr&lt;EditorMemento&gt;;</span><br><span class="line">public:</span><br><span class="line">    void Type(const std::string&amp; words) &#123; content_ += &quot; &quot; + words; &#125;</span><br><span class="line">    const std::string&amp; GetContent() const &#123; return content_; &#125;</span><br><span class="line">    MementoType Save() &#123; return std::make_shared&lt;EditorMemento&gt;(content_); &#125;</span><br><span class="line">    void Restore(MementoType memento) &#123; content_ = memento-&gt;GetContent(); &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string content_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Editor editor;</span><br><span class="line">    //! Type some stuff</span><br><span class="line">    editor.Type(&quot;This is the first sentence.&quot;);</span><br><span class="line">    editor.Type(&quot;This is second.&quot;);</span><br><span class="line">    //! Save the state to restore to : This is the first sentence. This is second.</span><br><span class="line">    auto saved = editor.Save();</span><br><span class="line">    //! Type some more</span><br><span class="line">    editor.Type(&quot;And this is third.&quot;);</span><br><span class="line">    std::cout &lt;&lt; editor.GetContent() &lt;&lt; std::endl;</span><br><span class="line">    editor.Restore(saved);</span><br><span class="line">    std::cout &lt;&lt; editor.GetContent() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>备忘录模式, 说白了就是对<strong>缓存</strong>这个行为的对象化. 我们通常想缓存一个状态, 会把这个状态存到容器中(如哈希表, map等), 并用某个 key (如时间戳) 来标定. 但当你要实现的, 是一个颇具规模, 多种状态缓存, 以及各种”存-取”穿插的时候, 将状态抽象成一个对象, 就显得十分必要了. 磨刀不误砍柴工, 在特定的场景下, 该模式不是没事找事, 而是真的会简化业务逻辑.</p>
<h3 id="😎-观察者"><a href="#😎-观察者" class="headerlink" title="😎 观察者"></a>😎 观察者</h3><p>真实案例:</p>
<blockquote>
<p>一个好例子: 求职者订阅了某职位发布网站, 当有何时的职位出现时, 他们会收到通知.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>定义对象间的依赖关系, 以至于一个对象的状态改变, 依赖它的对象们都会收到通知.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class JobPost &#123;</span><br><span class="line">public:</span><br><span class="line">    JobPost(const std::string&amp; title): title_(title) &#123;&#125;</span><br><span class="line">    const std::string&amp; GetTitle() const &#123; return title_; &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string title_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IObserver &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void OnJobPosted(const JobPost&amp; job) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class JobSeeker : public IObserver &#123;</span><br><span class="line">public:</span><br><span class="line">    JobSeeker(const std::string&amp; name): name_(name) &#123;&#125;</span><br><span class="line">    void OnJobPosted(const JobPost &amp;job) override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Hi &quot; &lt;&lt; name_ &lt;&lt; &quot;! New job posted: &quot; &lt;&lt; job.GetTitle() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IObservable &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Attach(IObserver&amp; observer) = 0;</span><br><span class="line">    virtual void AddJob(const JobPost&amp; jobPosting) = 0;</span><br><span class="line">protected:</span><br><span class="line">    virtual void Notify(const JobPost&amp; jobPosting) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class JobPostings : public IObservable &#123;</span><br><span class="line">public:</span><br><span class="line">    void Attach(IObserver&amp; observer) override &#123;</span><br><span class="line">        observers_.push_back(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    void AddJob(const JobPost &amp;jobPosting) override &#123;</span><br><span class="line">        Notify(jobPosting);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void Notify(const JobPost &amp;jobPosting) override &#123;</span><br><span class="line">        for (IObserver&amp; observer : observers_)</span><br><span class="line">            observer.OnJobPosted(jobPosting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::reference_wrapper&lt;IObserver&gt;&gt; observers_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    JobSeeker johnDoe(&quot;John Doe&quot;);</span><br><span class="line">    JobSeeker janeDoe(&quot;Jane Doe&quot;);</span><br><span class="line"></span><br><span class="line">    JobPostings jobPostings;</span><br><span class="line">    jobPostings.Attach(johnDoe);</span><br><span class="line">    jobPostings.Attach(janeDoe);</span><br><span class="line"></span><br><span class="line">    jobPostings.AddJob(JobPost(&quot;Software Engineer&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>又被称为发布-订阅模式. 但无论叫什么, 其实本质都是<strong>注入+回调</strong>. 订阅是注入的时机, 发布是回调的时机. 观察是注入的时机, 通知是回调的时机. 在实践中, 通常会维护一个订阅列表, 有点类似邮件列表. 发布通知时, 会迭代每一个注入对象, 并执行回调.</p>
<h3 id="🏃-访问者"><a href="#🏃-访问者" class="headerlink" title="🏃 访问者"></a>🏃 访问者</h3><p>真实案例:</p>
<blockquote>
<p>假设有人要去迪拜, 他只需要一种方式(例如签证)进入迪拜. 到了之后, 就可以去访问迪拜的任何地方, 而用不着额外申请许可, 或是做一些法律事宜. 只需要让他知道一个地方, 他就可以去访问了. 访问者模式可以做到这一点, 它帮助你添加地点, 以便你无需额外工作就可以尽可能的访问更多地方.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>访问者模式允许你为对象们增加更多的操作, 却不必修改它们.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures. It is one way to follow the open/closed principle.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class AnimalOperation;</span><br><span class="line"></span><br><span class="line">// visitee</span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Accept(AnimalOperation&amp; operation) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Monkey;</span><br><span class="line">class Lion;</span><br><span class="line">class Dolphin;</span><br><span class="line"></span><br><span class="line">// visitor</span><br><span class="line">class AnimalOperation &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void visitMonkey(Monkey&amp; monkey) = 0;</span><br><span class="line">    virtual void visitLion(Lion&amp; lion) = 0;</span><br><span class="line">    virtual void visitDolphin(Dolphin&amp; dolphin) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Monkey : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void Shout() &#123; std::cout &lt;&lt; &quot;Ooh oo aa aa!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Accept(AnimalOperation&amp; operation) override &#123; operation.visitMonkey(*this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Lion : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void Roar() &#123; std::cout &lt;&lt; &quot;Roaaar!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Accept(AnimalOperation&amp; operation) override &#123; operation.visitLion(*this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dolphin : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void Speak() &#123; std::cout &lt;&lt; &quot;Tuut tuttu tuutt!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Accept(AnimalOperation&amp; operation) override &#123; operation.visitDolphin(*this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Speak : public AnimalOperation &#123;</span><br><span class="line">public:</span><br><span class="line">    void visitMonkey(Monkey&amp; monkey) override &#123; monkey.Shout(); &#125;</span><br><span class="line">    void visitLion(Lion&amp; lion) override &#123; lion.Roar(); &#125;</span><br><span class="line">    void visitDolphin(Dolphin&amp; dolphin) override &#123; dolphin.Speak(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Monkey monkey;</span><br><span class="line">    Lion lion;</span><br><span class="line">    Dolphin dolphin;</span><br><span class="line"></span><br><span class="line">    Speak speak;</span><br><span class="line">    monkey.Accept(speak);</span><br><span class="line">    lion.Accept(speak);</span><br><span class="line">    dolphin.Accept(speak);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>其实本质依然是<strong>注入-回调</strong>模式. 签证是一种注入, 允许你回调 <code>visit</code>; 告诉地点是一种注入, 允许去具体地点回调 <code>visit</code>. 从示例代码看, 也能看出两层注入回调的意思: 首先是针对<strong>接口</strong>的注入回调, 通过 <code>Accept</code> 注入动物行为, 然后回调各个 <code>visit</code> 方法, 在回调的同时, 又将自身注入(此刻已经是针对<strong>具体</strong>对象了), 然后再回调具体的动物行为方法.</p>
<p>为什么要这样绕来绕去, 来来回回的呢? 那是因为访问者是一种<strong>维护</strong>模式. 试想, 既有代码已经存在 Animal 和其三个派生类了, 以及各自嚎叫的方法. 现在我想用一个<strong>统一的接口, 去迭代的调用这些方法</strong>(假想三个对象都在一个 vector 中, 你迭代的时候无法用各自不同的接口). 那么就需要访问者上场了. 首先在 Animal 类中增加接口 <code>Accept</code>, 留出注入的口子. 然后派生类重写该接口, 并借此将自身注入. 最后将这些方法抽象成一个接口类, 并增加相应的 <code>visit</code> 方法. 派生该接口类, 将具体的方法一一绑定(就是在绑定回调). 然后我们一旦调用 <code>Accept</code>, 各自嚎叫的方法就会自然被回调到了.</p>
<p>综上, 访问者模式, 是一种对<strong>调用</strong>的抽象, 依靠<strong>回调</strong>来实现.</p>
<h3 id="💡-策略"><a href="#💡-策略" class="headerlink" title="💡 策略"></a>💡 策略</h3><p>真实案例:</p>
<blockquote>
<p>以排序算法为例, 最初我们采用冒泡排序, 但随着数据数量的增长, 冒泡排序越来越慢. 为了解决这个问题, 我们改用快速排序. 但虽然对于大型数据集来说效果好了起来, 但对于比较小的数据集而言, 却相当慢. 为了处理这样一个两难, 我们采取了一个策略: 对于小型数据集, 采用冒泡排序; 对于较大一些的, 采用快速排序.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>策略模式允许你根据实际情况切换算法或策略.</p>
</blockquote>
<p>Wikipadia:</p>
<blockquote>
<p>In computer programming, the strategy pattern (also known as the policy pattern) is a behavioural software design pattern that enables an algorithm’s behavior to be selected at runtime.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class ISortStrategy &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Sort(std::vector&lt;int&gt;&amp; vec) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BubbleSortStrategy : public ISortStrategy &#123;</span><br><span class="line">public:</span><br><span class="line">    void Sort(std::vector&lt;int&gt;&amp; vec) override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Sorting using bubble sort&quot; &lt;&lt; std::endl;</span><br><span class="line">        _BubbleSort(vec);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void _BubbleSort(std::vector&lt;int&gt;&amp; vec) &#123;</span><br><span class="line">        using size = std::vector&lt;int&gt;::size_type;</span><br><span class="line">        for (size i = 0; i != vec.size(); ++i)</span><br><span class="line">            for (size j = 0; j != vec.size()-1; ++j)</span><br><span class="line">                if (vec[j] &gt; vec[j+1])</span><br><span class="line">                    std::swap(vec[j], vec[j+1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class QuickSortStrategy : public ISortStrategy &#123;</span><br><span class="line">public:</span><br><span class="line">    void Sort(std::vector&lt;int&gt;&amp; vec) override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Sorting using quick sort&quot; &lt;&lt; std::endl;</span><br><span class="line">        _QuickSort(vec);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void _QuickSort(std::vector&lt;int&gt;&amp; vec) &#123;</span><br><span class="line">        using size = std::vector&lt;int&gt;::size_type;</span><br><span class="line">        auto partition = [&amp;vec](size low, size high) &#123;</span><br><span class="line">            int pivot = vec[high];</span><br><span class="line">            size i = low;</span><br><span class="line">            for (size j = low; j != high; ++j)</span><br><span class="line">                if (vec[j] &lt;= pivot)</span><br><span class="line">                    std::swap(vec[i++], vec[j]);</span><br><span class="line">            std::swap(vec[i], vec[high]);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        std::function&lt;void (size, size)&gt; quickSort = [&amp;](size low, size high) &#123;</span><br><span class="line">            if (low &gt;= high) return;</span><br><span class="line">            size pi = partition(low, high);</span><br><span class="line">            quickSort(low, pi - 1);</span><br><span class="line">            quickSort(pi + 1, high);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(0, vec.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sorter &#123;</span><br><span class="line">public:</span><br><span class="line">    static void Sort(std::vector&lt;int&gt;&amp; vec, const std::shared_ptr&lt;ISortStrategy&gt;&amp; sorter) &#123; sorter-&gt;Sort(vec); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; vec&#123;1, 5, 4, 3, 2, 8&#125;;</span><br><span class="line"></span><br><span class="line">    Sorter::Sort(vec, std::make_shared&lt;BubbleSortStrategy&gt;());</span><br><span class="line">    for (int i : vec) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Sorter::Sort(vec, std::make_shared&lt;QuickSortStrategy&gt;());</span><br><span class="line">    for (int i : vec) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>策略模式的本质依然是<strong>注入+多态</strong>, 将接口注入, 调用相应方法(算法或策略)时, 再根据多态的特性来选择具体实现.</p>
<h3 id="💢-状态"><a href="#💢-状态" class="headerlink" title="💢 状态"></a>💢 状态</h3><p>真实案例:</p>
<blockquote>
<p>假设你正在使用”画图”程序, 选择了画笔工具来进行绘制. 画刷会根据你选择的颜色而改变其行为: 譬如你选择了红色, 它便会用红色来绘制; 如果选择了蓝色, 它将成为蓝色.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>它让你在状态改变的同时, 也改变类的行为</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>The state pattern is a behavioral software design pattern that implements a state machine in an object-oriented way. With the state pattern, a state machine is implemented by implementing each individual state as a derived class of the state pattern interface, and implementing state transitions by invoking methods defined by the pattern’s superclass. The state pattern can be interpreted as a strategy pattern which is able to switch the current strategy through invocations of methods defined in the pattern’s interface.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<p>以一个文字处理程序为例, 那些敲上去的字, 你可以改变它们的状态. 例如, 你选择了加粗, 后续的字都会是粗的, 同样的, 选择了斜体, 后续都会是斜体.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class IWritingState &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Write(std::string words) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class UpperCase : public IWritingState &#123;</span><br><span class="line">    void Write(std::string words) override &#123;</span><br><span class="line">        std::transform(words.begin(), words.end(), words.begin(), ::toupper);</span><br><span class="line">        std::cout &lt;&lt; words &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LowerCase : public IWritingState &#123;</span><br><span class="line">    void Write(std::string words) override &#123;</span><br><span class="line">        std::transform(words.begin(), words.end(), words.begin(), ::tolower);</span><br><span class="line">        std::cout &lt;&lt; words &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Default : public IWritingState &#123;</span><br><span class="line">    void Write(std::string words) override &#123; std::cout &lt;&lt; words &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TextEditor &#123;</span><br><span class="line">public:</span><br><span class="line">    TextEditor(const std::shared_ptr&lt;IWritingState&gt;&amp; state): state_(state) &#123;&#125;</span><br><span class="line">    void SetState(const std::shared_ptr&lt;IWritingState&gt;&amp; state) &#123; state_ = state; &#125;</span><br><span class="line">    void Type(std::string words) &#123; state_-&gt;Write(words); &#125;</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;IWritingState&gt; state_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  TextEditor editor(std::make_shared&lt;Default&gt;());</span><br><span class="line">  editor.Type(&quot;First line&quot;);</span><br><span class="line"></span><br><span class="line">  editor.SetState(std::make_shared&lt;UpperCase&gt;());</span><br><span class="line">  editor.Type(&quot;Second line&quot;);</span><br><span class="line">  editor.Type(&quot;Third line&quot;);</span><br><span class="line"></span><br><span class="line">  editor.SetState(std::make_shared&lt;LowerCase&gt;());</span><br><span class="line">  editor.Type(&quot;Fourth line&quot;);</span><br><span class="line">  editor.Type(&quot;Fifth line&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>状态模式的本质依然是<strong>注入+多态</strong>, 这和<a>策略</a>如出一辙. 实际上在实践中, 这俩模式几乎一样. 只有一些微小的差别:</p>
<ol>
<li>状态模式通常会缓存当前状态, 你可以通过 <code>get</code> 方法取得状态, 但策略模式通常不提供 <code>get</code> 方法.</li>
<li>状态模式会提供 <code>set</code> 方法替换状态, 但策略模式通常不提供 <code>set</code> 方法.(虽然可以用 assign constructor 起到同样效果)</li>
<li>策略对象通常作为参数传递给当前对象, 而状态通常由当前对象所创建.</li>
<li>策略是针对特定方法的, 而状态却是针对整个对象的.</li>
</ol>
<p>详见<a href="https://stackoverflow.com/questions/1658192/what-is-the-difference-between-strategy-design-pattern-and-state-design-pattern" target="_blank" rel="noopener">https://stackoverflow.com/que…</a></p>
<p>总体来讲, 状态更像是一组策略的集合. 改变对象状态, 会让对象的各种方法都有改变. 而策略往往只是针对某特定算法的.</p>
<h3 id="📒-模板方法"><a href="#📒-模板方法" class="headerlink" title="📒 模板方法"></a>📒 模板方法</h3><p>真实案例:</p>
<blockquote>
<p>假设我们正在造房子, 其步骤看起来可能如下所示:</p>
<ol>
<li>建造地基</li>
<li>砌墙</li>
<li>建造屋顶</li>
<li>隔出楼层</li>
</ol>
<p>这些步骤的顺序是固定的, 即在砌墙之前不能建造屋顶, 但每个步骤都可以修改完善, 譬如砌墙也可以由木头或聚酯, 石头来替代.</p>
</blockquote>
<p>简言之:</p>
<blockquote>
<p>模板方法定义了如何执行某种算法的框架, 但将具体实现延迟到子类.</p>
</blockquote>
<p>Wikipedia:</p>
<blockquote>
<p>In software engineering, the template method pattern is a behavioral design pattern that defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses. It lets one redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</blockquote>
<p><strong>示例代码</strong>:</p>
<p>假设我们有一个构建工具来帮助我们测试, 检查, 构建, 生成构建报告(即代码覆盖报告, 检查结果报告等), 并将我们的应用部署到测试服务器上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Builder &#123;</span><br><span class="line">public:</span><br><span class="line">    void Build() &#123;</span><br><span class="line">        Test();</span><br><span class="line">        Lint();</span><br><span class="line">        Assemble();</span><br><span class="line">        Deploy();</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    virtual void Test() = 0;</span><br><span class="line">    virtual void Lint() = 0;</span><br><span class="line">    virtual void Assemble() = 0;</span><br><span class="line">    virtual void Deploy() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AndroidBuilder : public Builder &#123;</span><br><span class="line">    void Test() override &#123; std::cout &lt;&lt; &quot;Running android tests&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Lint() override &#123; std::cout &lt;&lt; &quot;Linting the android code&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Assemble() override &#123; std::cout &lt;&lt; &quot;Assembling the android build&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Deploy() override &#123; std::cout &lt;&lt; &quot;Deploying android build to server&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IosBuilder : public Builder &#123;</span><br><span class="line">    void Test() override &#123; std::cout &lt;&lt; &quot;Running ios tests&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Lint() override &#123; std::cout &lt;&lt; &quot;Linting the ios code&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Assemble() override &#123; std::cout &lt;&lt; &quot;Assembling the ios build&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">    void Deploy() override &#123; std::cout &lt;&lt; &quot;Deploying ios build to server&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    AndroidBuilder androidBuilder;</span><br><span class="line">    androidBuilder.Build();</span><br><span class="line"></span><br><span class="line">    IosBuilder iosBuilder;</span><br><span class="line">    iosBuilder.Build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>:</p>
<p>模板方法基本就是<strong>多态</strong>的集中体现. 只不过将所有多态方法集中到一个公共接口中. 不过模板方法的核心是, 通过这个统一接口, 确定各个具体接口方法的顺序, 以确立调用结构. 子类各自实现具体细节, 但行为, 结构依旧保持一致. 这就好比”C++ 标准”规定了语言的行为, 各家编译器去各自实现. 而最终, 只要你的代码遵循 C++ 标准, 原则上应该可以在各种编译器上得到一致的结果.</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>这篇笔记, 或称之为翻译, 断断续续写完, 竟然花了半个月的时间(业余时间). 但这是我对于网络上热门资源的一次精读试验. 毕竟有太多的资源, 被 star 或收藏以后就被忘之脑后, 并将积灰多年.</p>
<p>突然想重读设计模式, 源于我想重构<a href="https://github.com/pezy/imgproc" target="_blank" rel="noopener">imgproc</a>, 对于原作者所使用的<a href="https://github.com/pezy/imgproc/issues/1" target="_blank" rel="noopener">工厂方法实现</a>中, 有一大段 switch 语句, 看着甚是碍眼. 试想未来我试验 OpenCV 算法, 会不断加入更多的算法, 每一次都需要在多个地方增加不同的代码, 想想就头疼, 自己维护都嫌麻烦. 这才想到去了解一下通过 C++ 语言, 可以怎样更优雅的实现工厂方法.</p>
<p>在了解过程中, 又对自己是否真正理解了几个工厂产生了怀疑, 于是找到了这篇 star 过万的热文.</p>
<p>实际上, 这篇文章介绍的 23 种设计模式, 与<a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">四人帮那本书</a>完全对应. 唯一不同在于行为型设计模式那里, 顺序不太一致. 所以你也可以把这篇文章视为”精简版” 的&lt;设计模式 - 可复用面向对象软件的基础&gt;.</p>
<p>但在精读的过程中, 还是发现了不少问题的, 尤其是针对其示例代码, 其实有一些例子举得并不恰当(上面笔记有提及). 而且明显有强关联的一些模式之间, 却各举各的例子(如三个工厂). 对于稍微复杂的模式, 如(观察者, 访问者), 写的又过于肤浅, 例子浮于表面. 感觉重点不够分明, 适合推广普及, 却不耐咀嚼. 建议配合四人帮那本书一起参阅. (不得不说, 那本书里面的例子, 质量相当高)</p>
<p><strong>最后划一下重点</strong>:</p>
<p>说起来 23 种设计模式, 很吓人的样子, 其实应该重点掌握的只有几个而已:</p>
<ul>
<li>创建型模式中, 重点掌握<strong>三个工厂, 与单例</strong>. 简单工厂实际上算不上模式(书里都没单独列出), 关键就是工厂方法, 抽象工厂只不过是工厂的工厂而已. 那么工厂方法其实抽象的是<code>new</code>的过程, 那么关键就是 <code>new</code> 的两边都应该是抽象接口, 封装掉具体实现. 单例模式, 要先了解其弊端, 但那也是它最核心的特点: 全局性. 这玩意会在实际开发中大量使用, 但理想情况下应该是避免的. 剩下俩: 原型就是 copy, 生成器就是”拆迁构造器”.</li>
<li><p>结构型模式中, 重点掌握<strong>桥接</strong>, 这个模式是重构神器. 如果领导说, 这个类太复杂了, 把它”抽一抽”, “单拎出来”. 那么十有八九是运用桥接模式. 结构型其实可以按以下基本特性分个类:</p>
<ul>
<li><strong>加</strong>一层: 适配器, 外观, 代理</li>
<li><strong>减</strong>肥: 桥接</li>
<li>常见编程技巧: 组合(就是基于接口迭代), 享元(哈希表), 装饰(不断实例化修改父类成员)</li>
</ul>
</li>
<li><p>行为型模式中, 重点掌握<strong>观察者</strong>和<strong>访问者</strong>. 行为型模式都有一个共同的特点, 就是非常讲究<strong>注入</strong>和<strong>回调</strong>这两个手段. 尤其以观察者与访问者, 用的登峰造极. 前者是所有消息系统的灵魂, 重点掌握消息列表, 与通知的时机. 后者是著名的<strong>IoC(控制反转)</strong>与<strong>DI(依赖注入)</strong>的灵魂. 这也是维护老系统必备的技巧. 它的重点是在<strong>不破坏已有接口</strong>的前提下, 如何增加新的特性. 剩下的模式我们也大致分个类:</p>
<ul>
<li>基本数据结构在面向对象的体现: 责任链(对象链表轮询), 命令(ACID), 迭代器(C++ 中的 iterator), 备忘录(缓存状态), 状态(状态机)</li>
<li>DI: 中介者(注入中介), 观察者(注入订阅者), 访问者(注入访问接口), 策略(注入算法对象)</li>
<li>常见编程技巧: 模板方法(固定接口, 子类实现)</li>
</ul>
</li>
</ul>
<p>Tips: 不同大类的模式, 也许名字听着类似, 但实质却完全不同. 如中介者, 与适配器, 代理, 感觉就很类似. 但中介者是被<strong>注入</strong>后起到作用的, 后两者却是<strong>在结构上</strong>增加了一层.</p>
<p>划出的几个重点也是面试常常考察的: 工厂, 单例, 桥接, 观察者, 访问者. 其余要么过于简单, 没啥好考察的; 要么已经和语言特性密不可分, 问起来容易被绕过去. 但这五者, 却很具备考察性, 要是能数清楚, 设计模式就算掌握了.</p>
<p>所有示例代码请见: <a href="https://github.com/pezy/DesignPatterns" target="_blank" rel="noopener">https://github.com/pezy/Desig…</a></p>
<h3 id="I-don’t-need-freedom"><a href="#I-don’t-need-freedom" class="headerlink" title="I don’t need freedom."></a>I don’t need freedom.</h3><p>More info: <a href="http://shierb.top" target="_blank" rel="noopener">shierb</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/18/设计模式/" data-id="cjudhakuu0013xix6uw9kvvr4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/18/IDEA快捷键/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          IDEA快捷键
        
      </div>
    </a>
  
  
    <a href="/2017/08/18/表达爱情/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">表达爱情</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心情/">心情</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜集/">搜集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/无聊/">无聊</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度/">深度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/大数据/" style="font-size: 10px;">大数据</a> <a href="/tags/心情/" style="font-size: 10px;">心情</a> <a href="/tags/搜集/" style="font-size: 20px;">搜集</a> <a href="/tags/无聊/" style="font-size: 15px;">无聊</a> <a href="/tags/深度/" style="font-size: 10px;">深度</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/3014/07/">July 3014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/3014/07/07/个人心情/">个人心情</a>
          </li>
        
          <li>
            <a href="/2020/05/20/JAVA汇总/">JAVA汇总</a>
          </li>
        
          <li>
            <a href="/2018/05/07/题题题题/">题题题题</a>
          </li>
        
          <li>
            <a href="/2017/12/19/深度工作/">深度工作</a>
          </li>
        
          <li>
            <a href="/2017/09/18/IDEA快捷键/">IDEA快捷键</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>